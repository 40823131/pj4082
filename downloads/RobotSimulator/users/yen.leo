<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="leo.20210411132449.1"><vh>@settings</vh>
<v t="leo.20210411132449.2"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="leo.20210411132449.3"><vh>@string initial_split_orientation = horizontal</vh></v>
</v>
<v t="leo.20210411135810.1"><vh>Project 4082</vh></v>
<v t="leo.20210411161804.1"><vh>Heroku site</vh></v>
<v t="leo.20210411151110.1"><vh>PyQt5, Pyside2 or Pysimplegui</vh></v>
<v t="leo.20210411154008.1"><vh>PySimpleGUI</vh>
<v t="leo.20210411153333.1"><vh>@path ./../pysimplegui_ex</vh>
<v t="leo.20210411153340.1"><vh>@clean hello_world.py</vh>
<v t="leo.20210411153407.1"><vh>Declarations (hello_world.py)</vh></v>
</v>
<v t="leo.20210411153417.1"><vh>@clean pysimpleGUI_ex1.py</vh>
<v t="leo.20210411153437.1"><vh>Declarations (pysimpleGUI_ex1.py)</vh></v>
</v>
<v t="leo.20210411153520.1"><vh>@clean pysimpleGUI_ex2.py</vh>
<v t="leo.20210411153540.1"><vh>Declarations (pysimpleGUI_ex2.py)</vh></v>
</v>
<v t="leo.20210411153611.1"><vh>@clean pysimpleGUIQt_ex1.py</vh>
<v t="leo.20210411153620.1"><vh>Declarations (pysimpleGUIQt_ex1.py)</vh></v>
</v>
<v t="leo.20210411153622.1"><vh>@clean pysimpleGUIQt_ex2.py</vh>
<v t="leo.20210411153632.1"><vh>Declarations (pysimpleGUIQt_ex2.py)</vh></v>
</v>
</v>
</v>
<v t="leo.20210411211731.1"><vh>@path ./../../</vh>
<v t="leo.20210411211751.1"><vh>@edit dh_coding_1.py</vh></v>
<v t="leo.20210411212006.1"><vh>@edit dh_coding_2.py</vh></v>
<v t="leo.20210411212154.1"><vh>@edit dh_coding_3.py</vh></v>
</v>
<v t="leo.20210411151136.1"><vh>import source code</vh>
<v t="leo.20210411132229.1"><vh>recursive importer</vh></v>
</v>
<v t="leo.20210411145736.1"><vh>@path ./../Robots</vh>
<v t="leo.20210411145758.1"><vh>@edit ABB_IRB120.xml</vh></v>
</v>
<v t="leo.20210411145610.1"><vh>imported files</vh>
<v t="leo.20210411145610.2"><vh>@path ./../</vh>
<v t="leo.20210411145610.3"><vh>@clean ConfigRobot.py</vh>
<v t="leo.20210411145610.4"><vh>Declarations</vh></v>
<v t="leo.20210411145610.5"><vh>class ConfigRobot(object)</vh>
<v t="leo.20210411145610.6"><vh>ConfigRobot.__init__</vh></v>
<v t="leo.20210411145610.7"><vh>ConfigRobot.get_q_init</vh></v>
</v>
</v>
<v t="leo.20210411145610.8"><vh>@clean GlobalFunc.py</vh>
<v t="leo.20210411145610.9"><vh>Declarations</vh></v>
<v t="leo.20210411145610.10"><vh>RadToDeg</vh></v>
<v t="leo.20210411145610.11"><vh>DegToRad</vh></v>
<v t="leo.20210411145610.12"><vh>ConvertRPYToMat</vh></v>
<v t="leo.20210411145610.13"><vh>ConvertMatToRPY</vh></v>
<v t="leo.20210411145610.14"><vh>DHMatrix</vh></v>
<v t="leo.20210411145610.15"><vh>SmartDegSubstraction</vh></v>
<v t="leo.20210411145610.16"><vh>LoadGCode</vh></v>
</v>
<v t="leo.20210411145610.17"><vh>@clean graph.py</vh>
<v t="leo.20210411145610.18"><vh>Declarations</vh></v>
</v>
<v t="leo.20210411145610.19"><vh>@clean Kinematics.py</vh>
<v t="leo.20210411145610.20"><vh>Declarations</vh></v>
<v t="leo.20210411145610.21"><vh>class Kinematics(object)</vh>
<v t="leo.20210411145610.22"><vh>Kinematics.__init__</vh></v>
<v t="leo.20210411145610.23"><vh>Kinematics.Cal_AMatrix</vh></v>
</v>
<v t="leo.20210411145610.24"><vh>class FwdKinematics(Kinematics)</vh>
<v t="leo.20210411145610.25"><vh>FwdKinematics.__init__</vh></v>
<v t="leo.20210411145610.26"><vh>FwdKinematics.Cal_Fwd_Position</vh></v>
</v>
<v t="leo.20210411145610.27"><vh>class InvKinematics(Kinematics)</vh>
<v t="leo.20210411145610.28"><vh>InvKinematics.__init__</vh></v>
<v t="leo.20210411145610.29"><vh>InvKinematics.Cal_Sol</vh></v>
<v t="leo.20210411145610.30"><vh>InvKinematics.FindTheBestSolution</vh></v>
<v t="leo.20210411145610.31"><vh>InvKinematics.Cal_Inv_Position</vh></v>
</v>
</v>
<v t="leo.20210411145610.32"><vh>@clean main.py</vh>
<v t="leo.20210411145610.33"><vh>Declarations</vh></v>
<v t="leo.20210411145610.34"><vh>class RobotSimulator(QMainWindow)</vh>
<v t="leo.20210411145610.35"><vh>RobotSimulator.__init__</vh></v>
<v t="leo.20210411145610.36"><vh>RobotSimulator.setupUI</vh></v>
<v t="leo.20210411145610.37"><vh>RobotSimulator.ShowAbout</vh></v>
<v t="leo.20210411145610.38"><vh>RobotSimulator.Stop</vh></v>
<v t="leo.20210411145610.39"><vh>RobotSimulator.ViewGrid</vh></v>
<v t="leo.20210411145610.40"><vh>RobotSimulator.valueChangeJVars</vh></v>
<v t="leo.20210411145610.41"><vh>RobotSimulator.valueChangeEVars</vh></v>
<v t="leo.20210411145610.42"><vh>RobotSimulator.openFileNameDialog</vh></v>
<v t="leo.20210411145610.43"><vh>RobotSimulator.LoadFile</vh></v>
<v t="leo.20210411145610.44"><vh>RobotSimulator.Run</vh></v>
<v t="leo.20210411145610.45"><vh>RobotSimulator.timeEvent</vh></v>
<v t="leo.20210411145610.46"><vh>RobotSimulator.UpdateData</vh></v>
</v>
</v>
<v t="leo.20210411145610.47"><vh>@clean OpenGLControl.py</vh>
<v t="leo.20210411145610.48"><vh>Declarations</vh></v>
<v t="leo.20210411145610.49"><vh>class GLWidget(QtOpenGL.QGLWidget)</vh>
<v t="leo.20210411145610.50"><vh>GLWidget.__init__</vh></v>
<v t="leo.20210411145610.51"><vh>GLWidget.setXRotation</vh></v>
<v t="leo.20210411145610.52"><vh>GLWidget.setYRotation</vh></v>
<v t="leo.20210411145610.53"><vh>GLWidget.setZRotation</vh></v>
<v t="leo.20210411145610.54"><vh>GLWidget.setXYTranslate</vh></v>
<v t="leo.20210411145610.55"><vh>GLWidget.setZoom</vh></v>
<v t="leo.20210411145610.56"><vh>GLWidget.updateJoint</vh></v>
<v t="leo.20210411145610.57"><vh>GLWidget.initializeGL</vh></v>
<v t="leo.20210411145610.58"><vh>GLWidget.drawGL</vh></v>
<v t="leo.20210411145610.59"><vh>GLWidget.paintGL</vh></v>
<v t="leo.20210411145610.60"><vh>GLWidget.DrawPoint</vh></v>
<v t="leo.20210411145610.61"><vh>GLWidget.resizeGL</vh></v>
<v t="leo.20210411145610.62"><vh>GLWidget.mousePressEvent</vh></v>
<v t="leo.20210411145610.63"><vh>GLWidget.drawGrid</vh></v>
<v t="leo.20210411145610.64"><vh>GLWidget.mouseMoveEvent</vh></v>
<v t="leo.20210411145610.65"><vh>GLWidget.setupColor</vh></v>
<v t="leo.20210411145610.66"><vh>GLWidget.xRotation</vh></v>
<v t="leo.20210411145610.67"><vh>GLWidget.yRotation</vh></v>
<v t="leo.20210411145610.68"><vh>GLWidget.zRotation</vh></v>
<v t="leo.20210411145610.69"><vh>GLWidget.normalizeAngle</vh></v>
</v>
</v>
<v t="leo.20210411145610.70"><vh>@clean Robot.py</vh>
<v t="leo.20210411145610.71"><vh>Declarations</vh></v>
<v t="leo.20210411145610.72"><vh>class Robot(object)</vh>
<v t="leo.20210411145610.73"><vh>Robot.__init__</vh></v>
<v t="leo.20210411145610.74"><vh>Robot.CalFwdPostion</vh></v>
<v t="leo.20210411145610.75"><vh>Robot.CalInvPostion</vh></v>
<v t="leo.20210411145610.76"><vh>Robot.CalInvPositionEx</vh></v>
<v t="leo.20210411145610.77"><vh>Robot.GetCurrentStatus</vh></v>
</v>
</v>
<v t="leo.20210411145610.78"><vh>@clean STLFile.py</vh>
<v t="leo.20210411145610.79"><vh>Declarations</vh></v>
<v t="leo.20210411145610.80"><vh>class createpoint</vh>
<v t="leo.20210411145610.81"><vh>createpoint.__init__</vh></v>
<v t="leo.20210411145610.82"><vh>createpoint.glvertex</vh></v>
</v>
<v t="leo.20210411145610.83"><vh>class createtriangle</vh>
<v t="leo.20210411145610.84"><vh>createtriangle.__init__</vh></v>
<v t="leo.20210411145610.85"><vh>createtriangle.calculate_vector</vh></v>
<v t="leo.20210411145610.86"><vh>createtriangle.calculate_normal</vh></v>
<v t="leo.20210411145610.87"><vh>createtriangle.cross_product</vh></v>
</v>
<v t="leo.20210411145610.88"><vh>class loader</vh>
<v t="leo.20210411145610.89"><vh>loader.__init__</vh></v>
<v t="leo.20210411145610.90"><vh>loader.get_triangles</vh></v>
<v t="leo.20210411145610.91"><vh>loader.draw</vh></v>
<v t="leo.20210411145610.92"><vh>loader.load_stl</vh></v>
<v t="leo.20210411145610.93"><vh>loader.load_text_stl</vh></v>
<v t="leo.20210411145610.94"><vh>loader.load_binary_stl</vh></v>
</v>
</v>
<v t="leo.20210411145610.95"><vh>@clean Trajectory.py</vh>
<v t="leo.20210411145610.96"><vh>Declarations</vh></v>
<v t="leo.20210411145610.97"><vh>class Trajectory(object)</vh>
<v t="leo.20210411145610.98"><vh>Trajectory.__init__</vh></v>
<v t="leo.20210411145610.99"><vh>Trajectory.SetPoint</vh></v>
<v t="leo.20210411145610.100"><vh>Trajectory.SetSpTime</vh></v>
<v t="leo.20210411145610.101"><vh>Trajectory.Calculate</vh></v>
</v>
</v>
<v t="leo.20210411145610.102"><vh>@path Cad</vh></v>
<v t="leo.20210411145610.109"><vh>@path ./</vh>
<v t="leo.20210411145610.110"><vh>@clean bin_to_ascii.py</vh>
<v t="leo.20210411145610.111"><vh>Declarations</vh></v>
<v t="leo.20210411145610.112"><vh>load_binary_stl</vh></v>
<v t="leo.20210411145610.113"><vh>read_length</vh></v>
<v t="leo.20210411145610.114"><vh>read_header</vh></v>
<v t="leo.20210411145610.115"><vh>eformat</vh></v>
<v t="leo.20210411145610.116"><vh>write_as_ascii</vh></v>
<v t="leo.20210411145610.117"><vh>main</vh></v>
</v>
<v t="leo.20210411145610.118"><vh>@clean stlRW.py</vh>
<v t="leo.20210411145610.119"><vh>Declarations</vh></v>
<v t="leo.20210411145610.120"><vh>stlReadBinary</vh></v>
<v t="leo.20210411145610.121"><vh>stlReadAscii</vh></v>
<v t="leo.20210411145610.122"><vh>stlRead</vh></v>
<v t="leo.20210411145610.123"><vh>stlWriteBinary</vh></v>
<v t="leo.20210411145610.124"><vh>writeVector</vh></v>
<v t="leo.20210411145610.125"><vh>stlWriteAscii</vh></v>
<v t="leo.20210411145610.126"><vh>stlWrite</vh></v>
</v>
<v t="leo.20210411145610.127"><vh>@clean stlSplitter.py</vh>
<v t="leo.20210411145610.128"><vh>Declarations</vh></v>
<v t="leo.20210411145610.129"><vh>check_connection</vh></v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="leo.20210411132229.1">'''Recursively import all python files in a directory and clean the result.
ctrl + b to execute
'''

c.recursiveImport(
    dir_ = r'./',
    kind = '@clean',
    safe_at_file = False,
    theTypes = ['.py']
)</t>
<t tx="leo.20210411132449.1"></t>
<t tx="leo.20210411132449.2">QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /* 標題字型大小設定 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /* 沒有特別對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font 大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* 內文字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;'CherryPy', 'pytz', 'mako', 'beautifulsoup4', 'pymysql', 'peewee'
    /* 下方的 Minibuffer 標題字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /* 沒有直接對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="leo.20210411132449.3">horizontal: body pane to the left
vertical: body pane on the botton</t>
<t tx="leo.20210411135810.1">組員:

40823116
40823131
40823152
40823153

專題動機:

https://github.com/mdecourse/RobotSimulator 已經利用 PyQt5 與 PyOpenGL 建立一個能夠讀取 Gcode 並執行基本流程模擬的套件, 由於原始套件並沒有宣告 license, 在此承接此一專案進行修改, 將要採用 AGPL 使用授權.

階段一的任務將要建立 6 軸工業機器人的 xml 與零組件 stl 檔案間的整合.

繼續使用 PyQt5 或改用 Pyside6 或改為 PySimpleGUI?

直接使用 PySide6 (與 Qt6 對應) 整體架構比較單純, 但是 PySide6 開發速度較慢, GUI 寫法較複雜

採用 PySimpleGUI 的好處是程式相對簡潔, 但若 PySimpleGUI 停止開發或放慢開發速度, 則後續程式碼較難維護

由於目前 RobotSimpulator 採用 PyQt5, 而 Beginning PyQt: https://link.springer.com/book/10.1007/978-1-4842-5857-6 有較多的參考資料, 因此建議:

RoboSimulator 仍從 PyQt5 下手, 納入 xml robot 六軸機械手臂架構後, 再視情況轉用其他 GUI 框架.
</t>
<t tx="leo.20210411145610.1"></t>
<t tx="leo.20210411145610.10">def RadToDeg(value):
    return value * 180.0 / pi

</t>
<t tx="leo.20210411145610.100">def SetSpTime(self, time):
    self.sp_time = time

</t>
<t tx="leo.20210411145610.101">def Calculate(self):
    distance = np.linalg.norm(self.endPoint - self.startPoint)
    if abs(distance - 0) &lt; 0.01:
        return False, 
    T = distance/self.velocity
    if T == 0:
        return False, 
    numT = int(round(T/self.sp_time, 2))
    s0 = 0; sn = distance
    h = sn - s0
    a0 = s0
    a1 = 0
    a2 = 0
    a3 = 1.0/(2 * T**3) * 20*h
    a4 = 1.0/(2 * T**4) * (-30)*h
    a5 = 1.0/(2 * T**5) * 12*h
    point = np.array([[None, None, None]])
    vel = np.array([[None, None, None]])
    acc = np.array([[None, None, None]])
    for i in range(numT+1):
        t = i*self.sp_time
        s = a0 + a1*t + a2*t**2 + a3*t**3 + a4*t**4 + a5*t**5
        s_dot = a1 + 2*a2*t + 3*a3*t**2 + 4*a4*t**3 + 5*a5*t**4
        s_dot_dot = 2*a2 + 6*a3*t + 12*a4*t**2 + 20*a5*t**3
        point = np.append(point, [self.startPoint + ((self.endPoint - self.startPoint)/distance) * s], axis = 0)
        vel =  np.append(vel, [((self.endPoint - self.startPoint)/distance)*s_dot], axis = 0)
        acc =  np.append(acc, [((self.endPoint - self.startPoint)/distance)*s_dot_dot], axis = 0)

    point = np.delete(point, 0, axis = 0)
    vel = np.delete(vel, 0, axis = 0)
    acc = np.delete(acc, 0, axis = 0)
    return True, point, vel, acc
</t>
<t tx="leo.20210411145610.102"></t>
<t tx="leo.20210411145610.109"></t>
<t tx="leo.20210411145610.11">def DegToRad(value):
    return value * pi / 180.0

</t>
<t tx="leo.20210411145610.110">@path ./py_ex/
@others
if __name__ == '__main__':
    main()
@language python
@tabwidth -4
</t>
<t tx="leo.20210411145610.111">import struct
normals = []
points = []
triangles = []
triangle_number = 0
</t>
<t tx="leo.20210411145610.112">def load_binary_stl(fp):
    '''
    二位元 STL 檔案格式如下:
    檔案標頭共有 80 個字元(bytes), 內容通常省略, 但是內容不可使用 solid, 以免與文字檔案 STL 混淆
    UINT8[80] – Header
    UINT32 – Number of triangles (I:佔 4 bytes 的 unsigned integer)
  
    foreach triangle
    REAL32[3] – Normal vector (f:每一座標分量為一佔 4 bytes 的 float, 共佔 12 bytes)
    REAL32[3] – Vertex 1
    REAL32[3] – Vertex 2
    REAL32[3] – Vertex 3
    UINT16 – Attribute byte count (H:兩個 bytes 的 unsigned short, 表示 attribute byte count)
    end
  
    '''
    # 已經在外部開檔
    #fp=open(filename,'rb')
    header=fp.read(80)
    triangle_number = struct.unpack('I',fp.read(4))[0]
    #print(triangle_number)
    count=0
    while True:
        try:
            p=fp.read(12)
            if len(p)==12:
                n=[struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]]
                normals.append(n)
                l = len(points)
                #print(n)
            p=fp.read(12)
            if len(p)==12:
                p1=[struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]]
                points.append(p1)
                #print(p1)
            p=fp.read(12)
            if len(p)==12:
                p2=[struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]]
                points.append(p2)
            p=fp.read(12)
            if len(p)==12:
                p3=[struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]]
                points.append(p3)
                triangles.append((l, l+1, l+2))
            # 使用 count 來計算三角形平面個數
            # triangle_number 為 STL 檔案中的三角形個數
            count += 1
            #print(count)
            # 在前面 12*4 個 bytes 的 normal 與三個點資料後, 為
            # 一個 2 bytes 長的 unsigned short, 其值為零, 為 attribute
            fp.read(2)
            # 讀完所有三角平面後, 即跳出 while
            if count &gt; triangle_number:
                break
        except EOFError:
            break
    #fp.close()
</t>
<t tx="leo.20210411145610.113">def read_length(f):
    length = struct.unpack("@i", f.read(4))
    return length[0]
</t>
<t tx="leo.20210411145610.114">def read_header(f):
    f.seek(f.tell()+80)
    
</t>
<t tx="leo.20210411145610.115">def eformat(f, prec, exp_digits):
    s = "%.*e"%(prec, f)
    mantissa, exp = s.split('e')
    # add 1 to digits as 1 is taken by sign +/-
    return "%se%+0*d"%(mantissa, exp_digits+1, int(exp))
    
</t>
<t tx="leo.20210411145610.116">def write_as_ascii(outfilename):
    f = open(outfilename, "w")
    f.write ("solid "+outfilename+"\n")
    # write color
    f.write("\tcolor 0.816 0.816 0.816\n")
    scale = 1.0
    for n  in range(len(triangles)):
        #"{:e}".format(float_number)
        f.write ("\tfacet normal {} {} {}\n".format(eformat(normals[n][0]*scale, 6, 2) ,eformat(normals[n][1]*scale, 6, 2),eformat(normals[n][2]*scale, 6, 2)))
        f.write ("\t\touter loop\n")
        f.write ("\t\t\tvertex {} {} {}\n".format(eformat(points[triangles[n][0]][0]*scale, 6, 2),eformat(points[triangles[n][0]][1]*scale, 6, 2),eformat(points[triangles[n][0]][2]*scale, 6, 2)))
        f.write ("\t\t\tvertex {} {} {}\n".format(eformat(points[triangles[n][1]][0]*scale, 6, 2),eformat(points[triangles[n][1]][1]*scale, 6, 2),eformat(points[triangles[n][1]][2]*scale, 6, 2)))
        f.write ("\t\t\tvertex {} {} {}\n".format(eformat(points[triangles[n][2]][0]*scale, 6, 2),eformat(points[triangles[n][2]][1]*scale, 6, 2),eformat(points[triangles[n][2]][2]*scale, 6, 2)))
        f.write ("\t\tendloop\n")
        f.write ("\tendfacet\n")
    f.write ("endsolid "+outfilename)
    f.close()
</t>
<t tx="leo.20210411145610.117">def main():
    infilename = "kmol_bot-2.stl"
    outfilename = "kmol_bot-2a.stl"
    try:
        f = open(infilename, "rb")
        #read_header(f)
        #l = read_length(f)
        try:
            load_binary_stl(f)
            l = len(normals)
        except Exception as e:
            print("Exception",e)
        print(len(normals), len(points), len(triangles), l)
        write_as_ascii(outfilename)
        print("done")
    except Exception as e:
        print(e)
</t>
<t tx="leo.20210411145610.118">@path ./py_ex/
# STL reader-writer
#
# copyright 2014 Francesco Santini &lt;francesco.santini@gmail.com&gt;
#
# based on https://github.com/cmpolis/convertSTL by Chris Polis
# and BinarySTL https://github.com/sukhbinder/python by Sukhbinder Singh
#
# Released under the MIT/X license
# KMOLab 2020/12/24/modified
 
@others
if __name__ == "__main__":
    import sys
    fname = sys.argv[1]
    h,p,n,v1,v2,v3,isAscii = stlRead(fname)
    print(len(n))
    print(v1[0])
    stlWriteBinary("binary.stl", n, v1, v2, v3);
    stlWriteAscii("ascii.stl", n, v1, v2, v3);
@language python
@tabwidth -4
</t>
<t tx="leo.20210411145610.119">import numpy as np
from struct import unpack, pack
 
</t>
<t tx="leo.20210411145610.12">def ConvertRPYToMat(psi, theta, phi):
    Matrix = np.array([[cos(phi)*cos(theta), cos(phi)*sin(theta)*sin(psi) - sin(phi)*cos(psi), cos(phi)*sin(theta)*cos(psi)+sin(phi)*sin(psi)],
                        [sin(phi)*cos(theta), sin(phi)*sin(theta)*sin(psi) + cos(phi)*cos(psi), sin(phi)*sin(theta)*cos(psi)-cos(phi)*sin(psi)],
                        [-sin(theta), cos(theta)*sin(psi), cos(theta)*cos(psi)]])
    return Matrix

</t>
<t tx="leo.20210411145610.120">def stlReadBinary(fname):
    fp = open(fname, 'rb')
    Header = fp.read(80)
    nn = fp.read(4)
    Numtri = unpack('i', nn)[0]
    #print nn
    record_dtype = np.dtype([
                  ('normals', np.float32,(3,)),  
                  ('Vertex1', np.float32,(3,)),
                  ('Vertex2', np.float32,(3,)),
                  ('Vertex3', np.float32,(3,)) ,              
                  ('atttr', '&lt;i2',(1,) )
    ])
    data = np.fromfile(fp , dtype = record_dtype , count =Numtri)
    fp.close()
 
    Normals = data['normals']
    Vertex1= data['Vertex1']
    Vertex2= data['Vertex2']
    Vertex3= data['Vertex3']
 
    p = np.append(Vertex1,Vertex2,axis=0)
    p = np.append(p,Vertex3,axis=0) #list(v1)
    Points =np.array(list(set(tuple(p1) for p1 in p)))
 
    return Header,Points,Normals,Vertex1,Vertex2,Vertex3,False
 
</t>
<t tx="leo.20210411145610.121">def stlReadAscii(fname):
    fp = open(fname, 'r')
    Normals = []
    Vertex1 = []
    Vertex2 = []
    Vertex3 = []
    Points = []
    while True:
        line = fp.readline()
        if not line: break
        if line.find("solid") &gt; -1 or line.find("endfacet") &gt; -1: continue
        if line.find("facet normal") &gt; -1:
            normline = line[line.find("facet normal")+len("facet normal"):]
            normal = np.array([float(val.strip()) for val in normline.split()])
            Normals.append(normal)
            vertices = []
            fp.readline() # outer loop
            # read vertices after normal
            for vIndex in range(0,3):
                vLine = fp.readline()
                vLine = vLine[vLine.find("vertex")+len("vertex"):]
                vertices.append(np.array([float(val.strip()) for val in vLine.split()]))
            Vertex1.append(vertices[0])
            Vertex2.append(vertices[1])
            Vertex3.append(vertices[2])
            Points.extend(vertices)
            fp.readline() # endloop
    return "", Points, Normals, Vertex1, Vertex2, Vertex3,True
     
   
</t>
<t tx="leo.20210411145610.122">def stlRead(fname):
    fp = open(fname, "r")
    try:
        if fp.readline().find("solid") &gt; -1:
            fp.close()
            return stlReadAscii(fname)
        else:
            fp.close()
            return stlReadBinary(fname)
    except:
        return stlReadBinary(fname)
     
</t>
<t tx="leo.20210411145610.123">def stlWriteBinary(fname, normals, v1, v2, v3):
    with open(fname, "wb") as fout:
        # write 80 bytes header
        for i in range(0, 80): fout.write(pack("&lt;c", b" "))
        fout.write(pack("&lt;I", len(normals))) # number of triangles
        for i in range(0, len(normals)):
            fout.write(pack("&lt;fff", *normals[i]))
            fout.write(pack("&lt;fff", *v1[i]))
            fout.write(pack("&lt;fff", *v2[i]))
            fout.write(pack("&lt;fff", *v3[i]))
            fout.write(pack("&lt;H", 0)) # attribute
       
</t>
<t tx="leo.20210411145610.124">def writeVector(fd, vec):
    for v in vec:
        fd.write("{:.7e}".format(v))
        fd.write(" ")
       
</t>
<t tx="leo.20210411145610.125">def stlWriteAscii(fname, normals, v1, v2, v3):
    with open(fname, "w") as fout:
        fout.write("solid \n")
        for i in range(0, len(normals)):
            fout.write("  facet normal ")
            writeVector(fout, normals[i])
            fout.write("\n")
            fout.write("    outer loop\n")
            fout.write("      vertex ")
            writeVector(fout, v1[i])
            fout.write("\n")
            fout.write("      vertex ")
            writeVector(fout, v2[i])
            fout.write("\n")
            fout.write("      vertex ")
            writeVector(fout, v3[i])
            fout.write("\n")
            fout.write("    endloop\n")
            fout.write("  endfacet\n")
       
       
</t>
<t tx="leo.20210411145610.126">def stlWrite(fname, normals, v1, v2, v3, isAscii=False):
    if isAscii:
        stlWriteAscii(fname, normals, v1, v2, v3)
    else:
        stlWriteBinary(fname, normals, v1, v2, v3)

</t>
<t tx="leo.20210411145610.127">@path ./py_ex/
#!/usr/bin/env python
# STL splitter
# splits a STL file containing separate objects
#
# copyright 2014 Francesco Santini &lt;francesco.santini@gmail.com&gt;
#
# based on https://github.com/cmpolis/convertSTL by Chris Polis
# and BinarySTL https://github.com/sukhbinder/python by Sukhbinder Singh
#
# Released under the MIT/X license
# KMOLab modified 2020/12/24

@others
@language python
@tabwidth -4
</t>
<t tx="leo.20210411145610.128">import stlRW
import sys
from os import path

## functions

# maybe insert a tolerance for floating points?
</t>
<t tx="leo.20210411145610.129">def check_connection(tri1, tri2):
  for v1 in tri1[0:2]:
    for v2 in tri2[0:2]:
      if (v1[0] == v2[0] and v1[1] == v2[1] and v1[2] == v2[2]): return True
  return False
    

'''
if len(sys.argv) &lt; 2:
  print("Usage: " + sys.argv[0] + " &lt;file.stl&gt;")
  sys.exit(-1)
'''
#fname = sys.argv[1]
fname = "kmol_bot.stl"

print("Reading...")

head,points,n,v1,v2,v3,isAscii = stlRW.stlRead(fname)

print("Analyzing...")

faceTree = []

for triangleIndex in range(0, len(v1)):
  triangle = [ v1[triangleIndex], v2[triangleIndex], v3[triangleIndex], n[triangleIndex] ]
  connectedTo = []
  for treeindex in range(0, len(faceTree)):
    for face in faceTree[treeindex]:
      if check_connection(face, triangle):
        connectedTo.append(treeindex) # the triangle is connected to at least one triangle of the current treeIndex
        break
      
  if len(connectedTo) == 0:
    # this is a triangle from a new set
    #print "new set"
    faceTree.append([])
    faceTree[len(faceTree)-1].append(triangle)
  elif len(connectedTo) == 1:
    #print "existing set"
    # the triangle is connected to one set
    faceTree[connectedTo[0]].append(triangle)
  else:
    #print "connecting triangle"
    #this triangle connects two branches of the tree: collapse the branches
    faceTree[connectedTo[0]].append(triangle)
    for i in range(len(connectedTo)-1, 0, -1):
      faceTree[connectedTo[0]].extend(faceTree.pop(connectedTo[i]))
      
print("Number of separate objects: ", len(faceTree))

print("Writing files")

origFile, origExt = path.splitext(fname)
for i in range(0, len(faceTree)):
  newFile = origFile + "-" + str(i+1) + origExt
  print("Writing ", newFile)
  n = [field[2] for field in faceTree[i]]
  v1 = [field[0] for field in faceTree[i]] 
  v2 = [field[1] for field in faceTree[i]] 
  v3 = [field[2] for field in faceTree[i]]
  stlRW.stlWrite(newFile, n, v1, v2, v3)
</t>
<t tx="leo.20210411145610.13">def ConvertMatToRPY(Matrix):
    a11 = Matrix[0][0]
    a21 = Matrix[1][0]
    a31 = Matrix[2][0]
    a32 = Matrix[2][1]
    a33 = Matrix[2][2]
    theta = -asin(a31)
    psi = atan2(a32/cos(theta), a33/cos(theta))
    phi = atan2(a21/cos(theta), a11/cos(theta))
    return psi, theta, phi

</t>
<t tx="leo.20210411145610.14">def DHMatrix(q, d, a, alpha):
    return np.array([[cos(q), -cos(alpha)*sin(q), sin(alpha)*sin(q), a*cos(q)],
                    [sin(q), cos(alpha)*cos(q), -sin(alpha)*cos(q), a*sin(q)],
                    [0, sin(alpha), cos(alpha), d],
                    [0,0,0,1]])
</t>
<t tx="leo.20210411145610.15">def SmartDegSubstraction(v2, v1):
    # v2 and v1 is numpy array
    size = v2.shape[0]
    Result = v2 - v1
    for i in np.arange(size):
        if Result[i] &gt; pi:
            Result[i] -= 2 * pi
        elif (Result[i] &lt; -pi):
            Result[i] += 2 * pi
    return Result

</t>
<t tx="leo.20210411145610.16">def LoadGCode(filename, offsetx, offsety, offsetz):
    file_obj = open(filename, "r")
    list_of_line = file_obj.readlines()
    list_of_gcode = []
    act = int(0)
    list_of_point = []
    for ls in list_of_line:
        if ("G1" in ls) or ("M300" in ls):
            list_of_gcode.append(ls)
        if "(end of print job)" in ls:
            break

    for ls in list_of_gcode:
        if "M300" in ls:
            ls_split_space = ls.split(" ")
            if ls_split_space[1] == "S30.00":
                act = int(1)
            elif(ls_split_space[1] == "S50.00"):
                act = int(0)
        if "G1" in ls:
            ls_split_space = ls.split(" ")
            x = offsetx + float(ls_split_space[1][1:])
            y = offsety + float(ls_split_space[2][1:])
            z = offsetz
            list_of_point.append([x, y, z, act])
    return np.asarray(list_of_point)
</t>
<t tx="leo.20210411145610.17">@path ./
@others
if first == 'x':
    plt.plot(t, points[1][:, 0], 'r', t, points[1][:,1], 'g--', t, points[1][:, 2], 'b:')
    plt.xlabel('t(s)')
    plt.ylabel('mm')
    plt.title('Đồ thị điểm thao tác theo thời gian')
    plt.legend(['x', 'y', 'z'], loc = 'center right')

elif first == 'xdot':
    plt.plot(t, points[2][:, 0], 'r', t, points[2][:,1], 'g--', t, points[2][:, 2], 'b:')
    plt.xlabel('t(s)')
    plt.ylabel('mm/s')
    plt.title('Đồ thi vận tốc điểm thao tác theo thời gian')
    plt.legend(['vx', 'vy', 'vz'], loc = 'upper right')
elif first == 'xdotdot':
    plt.plot(t, points[3][:, 0], 'r', t, points[3][:,1], 'g--', t, points[3][:, 2], 'b:')
    plt.xlabel('t(s)')
    plt.ylabel('mm/s2')
    plt.title('Đồ thi gia tốc điểm thao tác theo thời gian')
    plt.legend(['ax', 'ay', 'az'], loc = 'upper right')
elif first == 'q':
    # print(len(AllJVar[:, 0]))
    plt.plot(t, AllJVar[:, 0], 'r', t, AllJVar[:, 1], 'g--', t, AllJVar[:, 2], 'b:', t, AllJVar[:, 3])
    plt.xlabel('t(s)')
    plt.ylabel('rad')
    plt.title('Bộ nghiệm thứ 4')
    plt.legend(['q1', 'q2', 'q3', 'q4'], loc = 'center right')

plt.grid()
plt.show()
print(objRB.EVars[3])
@language python
@tabwidth -4
</t>
<t tx="leo.20210411145610.18">from sys import argv
from GlobalFunc import *
import OpenGLControl as DrawRB
from Robot import *
from Trajectory import *
import numpy as np
import matplotlib.pyplot as plt
script, first = argv

trj = Trajectory()
f_point = np.array([220, 310, 70])
e_point = np.array([-100, 430, 260])
trj.SetSpTime(0.1)
trj.SetPoint(f_point, e_point, 30)
points = trj.Calculate()
T  = 0.1 * len(points[1])
t = np.arange(0., T, 0.1)
objRB = Robot()
AllJVar=np.array([[None, None, None, None]])
for p in points[1]:
    p = np.append(p, [objRB.EVars[3], objRB.EVars[4], objRB.EVars[5]])
    JVar = objRB.CalInvPositionEx(p, sol = 4)
    AllJVar = np.append(AllJVar, [JVar[1]], axis = 0)
AllJVar = np.delete(AllJVar, 0, axis = 0)

</t>
<t tx="leo.20210411145610.19">@path ./
@others
@language python
@tabwidth -4
</t>
<t tx="leo.20210411145610.2"></t>
<t tx="leo.20210411145610.20">import numpy as np 
import math
from math import *
from ConfigRobot import *
from GlobalFunc import *

</t>
<t tx="leo.20210411145610.21">class Kinematics(object):
    """docstring for Kinematics"""
    @others
</t>
<t tx="leo.20210411145610.22">def __init__(self):
    self.cf = ConfigRobot()
    self.q = []
    self.d = self.cf.d
    self.a = self.cf.a
    self.a[4] = self.a[4]
    self.alpha = self.cf.alpha

</t>
<t tx="leo.20210411145610.23">def Cal_AMatrix(self, q1, q2, q3, q4):
    A10 = DHMatrix(q1, self.d[1], self.a[1], self.alpha[1])
    A21 = DHMatrix(q2, self.d[2], self.a[2], self.alpha[2])
    A32 = DHMatrix(q3, self.d[3], self.a[3], self.alpha[3])
    A43 = DHMatrix(q4, self.d[4], self.a[4]+33, self.alpha[4])
    A40 = A10.dot(A21).dot(A32).dot(A43)

    return A40	
</t>
<t tx="leo.20210411145610.24">class FwdKinematics(Kinematics):
    """docstring for FwdKinematics"""
    @others
</t>
<t tx="leo.20210411145610.25">def __init__(self):
    super(FwdKinematics, self).__init__()
    
</t>
<t tx="leo.20210411145610.26">def Cal_Fwd_Position(self, JVars):
    q1 = JVars[0]
    q2 = JVars[1]
    q3 = JVars[2]
    q4 = JVars[3]
    AE = self.Cal_AMatrix(q1, q2, q3, q4)
    xE = AE[0][3]
    yE = AE[1][3]
    zE = AE[2][3]
    psi, theta, phi = ConvertMatToRPY(AE[0:3, 0:3])
    EVars = [xE, yE, zE, psi, theta, phi]
    return np.asarray(EVars)

</t>
<t tx="leo.20210411145610.27">class InvKinematics(Kinematics):
    """docstring for InvKinematics"""
    @others
</t>
<t tx="leo.20210411145610.28">def __init__(self):
    super(InvKinematics, self).__init__()

</t>
<t tx="leo.20210411145610.29">def Cal_Sol(self, sol):
    result = [1]*2
    if sol % 2:
        result[0] = 1
    else:
        result[0] = -1
    if sol &gt; 1 and sol &lt; 4:
        result[1] = -1
    return result

</t>
<t tx="leo.20210411145610.3">@path ./
@others
@language python
@tabwidth -4
</t>
<t tx="leo.20210411145610.30">def FindTheBestSolution(self, EVars, q1P, q2P):
    k1 = 0.9
    k2 = 0.1
    sp_time = 0.5
    W = [0] * 4
    for i in np.arange(4):
        result = self.Cal_Inv_Position(EVars, i+1)
        if result[0] == False:
            return None
        q = result[1]
        t1 = SmartDegSubstraction(q, q1P)
        tmp = SmartDegSubstraction(q1P, q2P)
        t2 = SmartDegSubstraction(q, q1P + sp_time * tmp)
        W[i] = k1 * np.sum(np.square(t1)) + k2 * np.sum(np.square(t2))
    Wmin = min(W)
    return W.index(Wmin) + 1

</t>
<t tx="leo.20210411145610.31">def Cal_Inv_Position(self, EVars, sol):
    xe = EVars[0]
    ye = EVars[1]
    ze = EVars[2]
    psi = EVars[3]
    theta = EVars[4]
    phi = EVars[5]
    s = self.Cal_Sol(sol)
    a4 = self.a[4]+33
    a3 = self.a[3]
    a2 = self.a[2]
    a1 = self.a[1]
    d3 = self.d[3]
    d2 = self.d[2]
    d1 = self.d[1]

    RPYMat = ConvertRPYToMat(psi, theta, phi)		
    nx = RPYMat[0][0]
    ny = RPYMat[1][0]
    nz = RPYMat[2][0]

    sx = RPYMat[0][1]
    sy = RPYMat[1][1]
    sz = RPYMat[2][1]

    ax = RPYMat[0][2]
    ay = RPYMat[1][2]
    az = RPYMat[2][2]
    try:
        r = sqrt(xe**2 + ye**2)
        _phi = atan2(xe/r, ye/r) 
        q1 = s[0] * acos((d2 + d3)/r) - _phi
        q234 = atan2(-nz, -sz)
        A = -ze + d1 - a4*sin(q234)
        B = cos(q1)*xe + sin(q1)*ye - a4*cos(q234)
        q3 = s[1] * acos((A**2 + B**2 - a2**2 - a3**2)/(2*a2*a3))

        delta = a3**2 * (sin(q3))**2 + (a3*cos(q3) + a2)**2
        deltas = A * (a3*cos(q3) + a2) - B*a3*sin(q3) 
        deltac = B * (a3*cos(q3) + a2) + A*a3*sin(q3)

        q2 = atan2(deltas/delta, deltac/delta)
        q4 = q234 - q3 - q2
        return True,  np.array([q1, q2, q3, q4])
    except Exception as e:
        return False, 

</t>
<t tx="leo.20210411145610.32">@path ./
@others
@language python
@tabwidth -4

</t>
<t tx="leo.20210411145610.33">import sys
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5.QtCore import *
from PyQt5.uic import *

from OpenGL.GL import *
from OpenGL.GLUT import *
from OpenGL.GLU import *


from GlobalFunc import *
import OpenGLControl as DrawRB
from Robot import *
from Trajectory import *


</t>
<t tx="leo.20210411145610.34">class RobotSimulator(QMainWindow):

    @others
app = QApplication(sys.argv)
window = RobotSimulator()
window.setupUI()
window.show()
sys.exit(app.exec_())
</t>
<t tx="leo.20210411145610.35">def __init__(self, *args):
    super(RobotSimulator, self).__init__(*args)

    loadUi('main.ui', self)
    self.timer  = QTimer()
    self.count = 0
    self.timer.timeout.connect(self.timeEvent)
    self.objRB = Robot()
    self.RB = DrawRB.GLWidget(self, self.objRB)
    # self.objRB.cf = ConfigRobot()
    self.UpdateData(1)
    self.UpdateData(2)
    self.fileName = None
    self.AllPoints = np.array([[None, None, None]])
    self.AllJVars = np.array([[None, None, None, None]])
    self.toolstatus = np.array([None])
    self.isRun = True


</t>
<t tx="leo.20210411145610.36">def setupUI(self):	
    self.setCentralWidget(self.RB)
    self.sliderQ1.setMinimum(-360)
    self.sliderQ1.setMaximum(360)
    self.sliderQ1.setValue(RadToDeg(self.objRB.cf.q_init[1]))
    self.sliderQ1.setTickInterval(1)
    self.sliderQ1.sliderMoved.connect(lambda: self.valueChangeJVars(0, self.sliderQ1.value()))

    self.sliderQ2.setMinimum(-360)
    self.sliderQ2.setMaximum(360)
    self.sliderQ2.setValue(RadToDeg(self.objRB.cf.q_init[2]))
    self.sliderQ2.setTickInterval(1)
    self.sliderQ2.sliderMoved.connect(lambda: self.valueChangeJVars(1, self.sliderQ2.value()))

    self.sliderQ3.setMinimum(-360)
    self.sliderQ3.setMaximum(360)
    self.sliderQ3.setValue(RadToDeg(self.objRB.cf.q_init[3]))
    self.sliderQ3.setTickInterval(1)
    self.sliderQ3.sliderMoved.connect(lambda: self.valueChangeJVars(2, self.sliderQ3.value()))

    self.sliderQ4.setMinimum(-360)
    self.sliderQ4.setMaximum(360)
    self.sliderQ4.setValue(RadToDeg(self.objRB.cf.q_init[4]))
    self.sliderQ4.setTickInterval(1)
    self.sliderQ4.sliderMoved.connect(lambda: self.valueChangeJVars(3, self.sliderQ4.value()))

    # self.setCentralWidget(self.RB)
    self.sliderX.setMinimum(-1000)
    self.sliderX.setMaximum(1000)
    self.sliderX.setValue(self.objRB.EVars[0])
    self.sliderX.setTickInterval(1)
    self.sliderX.sliderMoved.connect(self.valueChangeEVars)

    self.sliderY.setMinimum(-1000)
    self.sliderY.setMaximum(1000)
    self.sliderY.setValue(self.objRB.EVars[1])
    self.sliderY.setTickInterval(1)
    self.sliderY.sliderMoved.connect(self.valueChangeEVars)

    self.sliderZ.setMinimum(-1000)
    self.sliderZ.setMaximum(1000)
    self.sliderZ.setValue(self.objRB.EVars[2])
    self.sliderZ.setTickInterval(1)
    self.sliderZ.sliderMoved.connect(self.valueChangeEVars)

    self.sliderAngleR.setMinimum(-360)
    self.sliderAngleR.setMaximum(360)
    self.sliderAngleR.setValue(RadToDeg(self.objRB.EVars[3]))
    self.sliderAngleR.setTickInterval(1)
    self.sliderAngleR.sliderMoved.connect(self.valueChangeEVars)

    self.sliderAngleP.setMinimum(-360)
    self.sliderAngleP.setMaximum(360)
    self.sliderAngleP.setValue(RadToDeg(self.objRB.EVars[4]))
    self.sliderAngleP.setTickInterval(1)
    self.sliderAngleP.sliderMoved.connect(self.valueChangeEVars)

    self.sliderAngleY.setMinimum(-360)
    self.sliderAngleY.setMaximum(360)
    self.sliderAngleY.setValue(RadToDeg(self.objRB.EVars[5]))
    self.sliderAngleY.setTickInterval(1)
    self.sliderAngleY.sliderMoved.connect(self.valueChangeEVars)

    self.sliderAngleR.setEnabled = False
    self.btnOpenFile.clicked.connect(self.openFileNameDialog)
    self.btnLoadFile.clicked.connect(self.LoadFile)
    self.btnRun.clicked.connect(self.Run)
    self.btnStop.clicked.connect(self.Stop)
    # self.btnClear.clicked.connect(self.Clear)
    # self.actionDock_Control_Panel.addAction(self.ViewGrid)
    self.actionDock_Control_Panel.triggered.connect(self.ViewGrid)
    self.actionAbout.triggered.connect(self.ShowAbout)
    self.btnUpdateStatusTab1.clicked.connect(lambda: self.UpdateData(1))
    self.btnUpdateStatusTab2.clicked.connect(lambda: self.UpdateData(2))

</t>
<t tx="leo.20210411145610.37">def ShowAbout(self):
    msg = QMessageBox()
    msg.setIcon(QMessageBox.Information)
    msg.setText("Robot Simulator")
    msg.setInformativeText("Project: Robot design\
        \n\nCode by: Nguyen Van Khuong\
        \nSource code: https://github.com/khuonghust/RobotSimulator\
        \nVideo demo: https://tinyurl.com/robot-simulation-python-opengl")
    msg.setWindowTitle("About Dialog")
    msg.exec_()

</t>
<t tx="leo.20210411145610.38">def Stop(self):
    self.isRun = False

</t>
<t tx="leo.20210411145610.39">def ViewGrid(self):
    self.RB.isDrawGrid = not (self.RB.isDrawGrid)
    self.RB.updateGL()

</t>
<t tx="leo.20210411145610.4">from GlobalFunc import *
import numpy as np
</t>
<t tx="leo.20210411145610.40">def valueChangeJVars(self, index, value):
    self.objRB.JVars[index] = DegToRad(value)
    self.objRB.CalFwdPostion(self.objRB.JVars)
    self.RB.updateGL()
    self.UpdateData(1)

</t>
<t tx="leo.20210411145610.41">def valueChangeEVars(self):
    x = self.sliderX.value()
    y = self.sliderY.value()
    z = self.sliderZ.value()
    psi = DegToRad(self.sliderAngleR.value())
    theta = DegToRad(self.sliderAngleP.value())
    phi =  DegToRad(self.sliderAngleY.value())
    EVars = np.array([x, y, z, psi, theta, phi])
    self.objRB.CalInvPostion(EVars)
    self.UpdateData(2)
    self.RB.updateGL()

</t>
<t tx="leo.20210411145610.42">def openFileNameDialog(self):    
    options = QFileDialog.Options()
    options |= QFileDialog.DontUseNativeDialog
    self.fileName, _ = QFileDialog.getOpenFileName(self,"Openfile", "","Gcode Files (*.gcode);;All Files (*)", options=options)
    self.processLoadFile.setValue(0)
    self.valueStatus.setText("None...")

</t>
<t tx="leo.20210411145610.43">def LoadFile(self):
    self.UpdateData(1)
    self.UpdateData(2)
    if self.fileName == None:
        self.valueStatus.setText("Error: file is not found")
    else:
        self.count = 0
        self.RB.listPoints = np.array([[0,0,0]])
        self.RB.color=np.array([0])
        self.AllPoints = np.array([[None, None, None]])
        self.AllJVars = np.array([[None, None, None, None]])
        self.toolstatus = np.array([None])
        self.valueStatus.setText("Processing...")
        self.processLoadFile.setValue(30)
        listPoint = LoadGCode(self.fileName, self.objRB.EVars[0], self.objRB.EVars[1], self.objRB.EVars[2])
        self.RB.updateGL()
        trj = Trajectory()
        listPoint = np.insert(listPoint, 0, [self.objRB.EVars[0], self.objRB.EVars[1], self.objRB.EVars[2], 0], axis = 0)
        listPoint = np.append(listPoint, [[self.objRB.EVars[0], self.objRB.EVars[1], self.objRB.EVars[2], 0]], axis = 0)
        toolstt_tmp = np.array([None])
        trj.SetSpTime(0.1)
        for i in np.arange(len(listPoint)-1):
            p1 = listPoint[i][:3]
            p2 = listPoint[i+1][:3]
            if i==0 or i == len(listPoint)-2:
                trj.SetPoint(p1,p2,100)
            else:
                trj.SetPoint(p1, p2, 100)
            points = trj.Calculate()
            if points[0] == False:
                pass
            else:
                self.AllPoints = np.append(self.AllPoints, points[1], axis = 0)
                self.toolstatus = np.append(self.toolstatus, [listPoint[i+1][3]]*len(points[1]))
                    
        self.toolstatus = np.delete(self.toolstatus, 0)
        self.AllPoints = np.delete(self.AllPoints, 0, axis = 0)
        toolstt_tmp = np.delete(toolstt_tmp, 0)
        q1P = self.objRB.q1P
        q2P = self.objRB.q2P
        for p in self.AllPoints:
            EVars = np.append(p, [self.objRB.EVars[3], self.objRB.EVars[4], self.objRB.EVars[5]])
            JVar = self.objRB.CalInvPositionEx(EVars, q1P, q2P)
            if JVar[0] == False:
                break
            self.AllJVars = np.append(self.AllJVars, [JVar[1]], axis = 0)
            q2P = q1P
            q1P = JVar[1]
        
        self.AllJVars = np.delete(self.AllJVars, 0, axis = 0)
        self.processLoadFile.setValue(100)

        if len(self.AllJVars) == len(self.AllPoints):
            self.valueStatus.setText("All done")
        else:
            self.valueStatus.setText("Some points is missing")

</t>
<t tx="leo.20210411145610.44">def Run(self):
    if len(self.AllJVars)&gt; 1:
        self.isRun = True
        self.timeEvent()
    else:
        self.valueStatus.setText("Error: Data is empty.")

</t>
<t tx="leo.20210411145610.45">def timeEvent(self):
    try:
        self.objRB.JVars = self.AllJVars[self.count]
        self.RB.listPoints = np.append(self.RB.listPoints, [self.AllPoints[self.count]], axis = 0)
        if self.toolstatus[self.count] == 1:
            self.RB.color = np.append(self.RB.color, 1)
        else:
            self.RB.color = np.append(self.RB.color, 0)

        self.count +=1
        self.RB.updateGL()
    finally:
        if (self.count &lt; len(self.AllJVars) - 1) and self.isRun:
            QTimer.singleShot(0, self.timeEvent)
        else:
            self.valueStatus.setText("Done")

</t>
<t tx="leo.20210411145610.46">def UpdateData(self, tabsel):
    if tabsel == 1:
        self.sliderX.setValue(int(self.objRB.EVars[0]))
        self.sliderY.setValue(int(self.objRB.EVars[1]))
        self.sliderZ.setValue(int(self.objRB.EVars[2]))
        self.sliderAngleR.setValue(int(RadToDeg(self.objRB.EVars[3])))
        self.sliderAngleP.setValue(int(RadToDeg(self.objRB.EVars[4])))
        self.sliderAngleY.setValue(int(RadToDeg(self.objRB.EVars[5])))
    elif tabsel == 2:
        self.valueQ1.setText(str(int(RadToDeg(self.objRB.JVars[0]))))
        self.valueQ2.setText(str(int(RadToDeg(self.objRB.JVars[1]))))
        self.valueQ3.setText(str(int(RadToDeg(self.objRB.JVars[2]))))
        self.valueQ4.setText(str(int(RadToDeg(self.objRB.JVars[3]))))
        self.sliderQ1.setValue(int(RadToDeg(self.objRB.JVars[0])))
        self.sliderQ2.setValue(int(RadToDeg(self.objRB.JVars[1])))
        self.sliderQ3.setValue(int(RadToDeg(self.objRB.JVars[2])))
        self.sliderQ4.setValue(int(RadToDeg(self.objRB.JVars[3])))

    self.valueQ1.setText(str(int(RadToDeg(self.objRB.JVars[0]))))
    self.valueQ2.setText(str(int(RadToDeg(self.objRB.JVars[1]))))
    self.valueQ3.setText(str(int(RadToDeg(self.objRB.JVars[2]))))
    self.valueQ4.setText(str(int(RadToDeg(self.objRB.JVars[3]))))

    self.valueX.setText(str(format(self.objRB.EVars[0], '.2f')))
    self.valueY.setText(str(format(self.objRB.EVars[1], '.2f')))
    self.valueZ.setText(str(format(self.objRB.EVars[2], '.2f')))
    self.valueAngleR.setText(str(int(RadToDeg(self.objRB.EVars[3]))))
    self.valueAngleP.setText(str(int(RadToDeg(self.objRB.EVars[4]))))
    self.valueAngleY.setText(str(int(RadToDeg(self.objRB.EVars[5]))))

</t>
<t tx="leo.20210411145610.47">@path ./
@others
@language python
@tabwidth -4

</t>
<t tx="leo.20210411145610.48">from PyQt5 import QtCore, QtGui
from PyQt5 import QtOpenGL
from OpenGL import GLU
from OpenGL.GL import *
from OpenGL.GLUT import *
from numpy import array, arange
from STLFile import *
# from ConfigRobot import *
from GlobalFunc import *


</t>
<t tx="leo.20210411145610.49">class GLWidget(QtOpenGL.QGLWidget):
    xRotationChanged = QtCore.pyqtSignal(int)
    yRotationChanged = QtCore.pyqtSignal(int)
    zRotationChanged = QtCore.pyqtSignal(int)

    @others
</t>
<t tx="leo.20210411145610.5">class ConfigRobot(object):
    """docstring for ConfigRobot"""
    @others
</t>
<t tx="leo.20210411145610.50">def __init__(self, parent=None, objRobot=None):
    super(GLWidget, self).__init__(parent)
    self.objRobot = objRobot
    self.xRot = -2584
    self.yRot = 1376
    self.zRot = 0.0
    self.z_zoom = -3500
    self.xTran = 0
    self.yTran = 0
    self.isDrawGrid = True;
    print("Loading stl files...")
    self.model0 = loader('STLFile/Link0.STL')
    self.model1 = loader('STLFile/Link1.STL')
    self.model2 = loader('STLFile/Link2.STL')
    self.model3 = loader('STLFile/Link3.STL')
    self.model4 = loader('STLFile/Link4.STL')
    self.model5 = loader('STLFile/tool.STL')
    print("All done.")

    self.listPoints = np.array([[0,0,0]])
    self.AllList = np.array([self.listPoints])
    self.stt = np.array([])
    self.color=np.array([0])

</t>
<t tx="leo.20210411145610.51">def setXRotation(self, angle):
    self.normalizeAngle(angle)
    if angle != self.xRot:
        self.xRot = angle
        self.xRotationChanged.emit(angle)
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
        self.updateGL()

</t>
<t tx="leo.20210411145610.52">def setYRotation(self, angle):
    self.normalizeAngle(angle)
    if angle != self.yRot:
        self.yRot = angle
        self.yRotationChanged.emit(angle)
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
        # self.updateGL()

</t>
<t tx="leo.20210411145610.53">def setZRotation(self, angle):
    self.normalizeAngle(angle)
    if angle != self.zRot:
        self.zRot = angle
        self.zRotationChanged.emit(angle)
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
        self.updateGL()

</t>
<t tx="leo.20210411145610.54">def setXYTranslate(self, dx, dy):
    self.xTran += 3.0 * dx
    self.yTran -= 3.0 * dy
    self.updateGL()

</t>
<t tx="leo.20210411145610.55">def setZoom(self, zoom):
    self.z_zoom = zoom
    self.updateGL()

</t>
<t tx="leo.20210411145610.56">def updateJoint(self):
    self.updateGL()

</t>
<t tx="leo.20210411145610.57">def initializeGL(self):
    lightPos = (5.0, 5.0, 10.0, 1.0)
    reflectance1 = (0.8, 0.1, 0.0, 1.0)
    reflectance2 = (0.0, 0.8, 0.2, 1.0)
    reflectance3 = (0.2, 0.2, 1.0, 1.0)

    ambientLight = [0.7, 0.7, 0.7, 1.0]
    diffuseLight = [0.7, 0.8, 0.8, 1.0]
    specularLight = [0.4, 0.4, 0.4, 1.0]
    positionLight = [20.0, 20.0, 20.0, 0.0]

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambientLight);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuseLight)
    glLightfv(GL_LIGHT0, GL_SPECULAR, specularLight)
    glLightModelf(GL_LIGHT_MODEL_TWO_SIDE, 1.0)
    glLightfv(GL_LIGHT0, GL_POSITION, positionLight)

    glEnable(GL_LIGHTING)
    glEnable(GL_LIGHT0)
    glEnable(GL_DEPTH_TEST)
    glEnable(GL_NORMALIZE)
    # glEnable(GL_BLEND);
    glClearColor(0.0, 0.0, 0.0, 1.0)

</t>
<t tx="leo.20210411145610.58">def drawGL(self):
    glPushMatrix()
    if self.isDrawGrid:
        self.drawGrid()
    self.setupColor([96.0 / 255, 96 / 255.0, 192.0 / 255])
    self.model0.draw()
    self.setupColor([169.0 / 255, 169.0 / 255, 169.0 / 255])

    # Link1
    glTranslatef(0.0, 0.0, self.objRobot.d[1]);
    glRotatef(RadToDeg(self.objRobot.JVars[0]), 0.0, 0.0, 1.0)
    glTranslatef(self.objRobot.a[1], 0.0, 0.0)
    glRotatef(RadToDeg(self.objRobot.alpha[1]), 1.0, 0.0, 0.0);
    self.model1.draw()

    #Link2
    # self.setupColor([90.0 / 255, 150.0 / 255, 9.0 / 255])
    glTranslatef(0.0, 0.0, self.objRobot.d[2]);
    glRotatef(RadToDeg(self.objRobot.JVars[1]), 0.0, 0.0, 1.0)
    glTranslatef(self.objRobot.a[2], 0.0, 0.0)
    glRotatef(RadToDeg(self.objRobot.alpha[2]), 1.0, 0.0, 0.0);
    self.model2.draw()

    #Link3
    # self.setupColor([255.0 / 255, 255.0 / 255, 9.0 / 255])
    glTranslatef(0.0, 0.0, self.objRobot.d[3]);
    glRotatef(RadToDeg(self.objRobot.JVars[2]), 0.0, 0.0, 1.0)
    glTranslatef(self.objRobot.a[3], 0.0, 0.0)
    glRotatef(RadToDeg(self.objRobot.alpha[3]), 1.0, 0.0, 0.0);
    self.model3.draw()

    #Link4
    self.setupColor([105.0 / 255, 180.0 / 255, 0 / 255])
    glTranslatef(0.0, 0.0, self.objRobot.d[4]);
    glRotatef(RadToDeg(self.objRobot.JVars[3]), 0.0, 0.0, 1.0)
    glTranslatef(self.objRobot.a[4], 0.0, 0.0)
    glRotatef(RadToDeg(self.objRobot.alpha[4]), 1.0, 0.0, 0.0);
    self.model4.draw()
    self.setupColor([0.0/255, 180.0/255, 84.0/255])
    self.model5.draw()
    glPopMatrix()

</t>
<t tx="leo.20210411145610.59">def paintGL(self):
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    glPushMatrix()
    glTranslate(0, 0, self.z_zoom)
    glTranslate(self.xTran, self.yTran, 0)
    glRotated(self.xRot/16.0, 1.0, 0.0, 0.0)
    glRotated(self.yRot/16.0, 0.0, 1.0, 0.0)
    glRotated(self.zRot/16.0, 0.0, 0.0, 1.0)
    glRotated(+90.0, 1.0, 0.0, 0.0)
    self.drawGL()
    self.DrawPoint([255.0/255, 255.0/255, 255.0/255.0], 1.5)
    glPopMatrix()

</t>
<t tx="leo.20210411145610.6">def __init__(self):
    super(ConfigRobot, self).__init__()
    self.d = np.array([0, 89.2, -135.7, 130.4, 0])
    self.a = np.array([0, 0, 300, 383, 60.04])
    # self.alpha = math.pi/180*np.array([-90, 0, 0, 0])
    # self.q_init = math.pi/180*np.array([0, 0, 0, 0])
    self.alpha = DegToRad(np.array([0, -90, 0, 0, 0]))
    self.q_init = DegToRad(np.array([0, 55, -77, 112, 53]))
    
</t>
<t tx="leo.20210411145610.60">def DrawPoint(self, color, size):
    glPushMatrix()
    glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, self.color);
    glPointSize(size);		
    for i in np.arange(len(self.listPoints)-1):
        if self.color[i] == 1:
            glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, [1.0, 1.0, 1.0]);
            glBegin(GL_LINES);
            glVertex3f(self.listPoints[i][0], self.listPoints[i][1], self.listPoints[i][2])
            glVertex3f(self.listPoints[i+1][0], self.listPoints[i+1][1], self.listPoints[i+1][2])
            glEnd()
    glPopMatrix()

</t>
<t tx="leo.20210411145610.61">def resizeGL(self, width, height):
    side = min(width, height)
    if side &lt; 0:
        return
    glViewport(0, 0, width, height)
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    GLU.gluPerspective(35.0, width / float(height), 1.0, 20000.0)
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()
    glTranslated(0.0, 0.0, -40.0)

</t>
<t tx="leo.20210411145610.62">def mousePressEvent(self, event):
    self.lastPos = event.pos()

</t>
<t tx="leo.20210411145610.63">def drawGrid(self):
    glPushMatrix()
    # color = [255.0/255, 57.0/255, 0.0/255]
    color = [8.0/255, 108.0/255, 162.0/255]
    glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, color);
    step = 50
    num = 15
    for i in arange(-num, num+1):
        glBegin(GL_LINES)
        glVertex3f(i*step, -num * step, 0)
        glVertex3f(i*step, num*step, 0)
        glVertex3f(-num * step, i*step, 0)
        glVertex3f(num*step, i*step, 0)
        glEnd()
    glPopMatrix()

</t>
<t tx="leo.20210411145610.64">def mouseMoveEvent(self, event):
    dx = event.x() - self.lastPos.x()
    dy = event.y() - self.lastPos.y()
    if event.buttons() &amp; QtCore.Qt.LeftButton:
        self.setXRotation(self.xRot + 4 * dy)
        self.setYRotation(self.yRot - 4 * dx)
    elif event.buttons() &amp; QtCore.Qt.RightButton:
        self.setZoom(self.z_zoom + 5.0*dy)
    elif event.buttons() &amp; QtCore.Qt.MidButton:
        self.setXYTranslate(dx, dy)
    self.lastPos = event.pos()


</t>
<t tx="leo.20210411145610.65">def setupColor(self, color):
    glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, color);

</t>
<t tx="leo.20210411145610.66">def xRotation(self):
    return self.xRot

</t>
<t tx="leo.20210411145610.67">def yRotation(self):
    return self.yRot

</t>
<t tx="leo.20210411145610.68">def zRotation(self):
    return self.zRot  

</t>
<t tx="leo.20210411145610.69">def normalizeAngle(self, angle):
    while (angle &lt; 0):
        angle += 360 * 16
    while (angle &gt; 360 * 16):
        angle -= 360 * 16
</t>
<t tx="leo.20210411145610.7">def get_q_init(self):
    return self.q_init
</t>
<t tx="leo.20210411145610.70">@path ./
@others
@language python
@tabwidth -4

</t>
<t tx="leo.20210411145610.71">from ConfigRobot import *
from Kinematics import *
import numpy as np
</t>
<t tx="leo.20210411145610.72">class Robot(object):
    """docstring for Robot"""
    @others
</t>
<t tx="leo.20210411145610.73">def __init__(self):
    super(Robot, self).__init__()
    self.cf = ConfigRobot()
    self.q = self.cf.q_init
    self.d = self.cf.d
    self.a = self.cf.a
    self.alpha = self.cf.alpha
    self.fwd = FwdKinematics()
    self.inv = InvKinematics()
    self.JVars = self.cf.q_init[1:]
    self.q1P = self.JVars
    self.q2P = self.JVars
    self.EVars = np.array([])
    self.EVars = self.fwd.Cal_Fwd_Position(self.JVars)

</t>
<t tx="leo.20210411145610.74">def CalFwdPostion(self, JVars):
    self.JVars = JVars
    self.q1P = self.q2P = JVars
    self.EVars = self.fwd.Cal_Fwd_Position(JVars)

</t>
<t tx="leo.20210411145610.75">def CalInvPostion(self, EVars):
    sol = self.inv.FindTheBestSolution(EVars, self.q1P, self.q2P)
    if sol != None:
        result = self.inv.Cal_Inv_Position(EVars, sol)
        if result[0] != False:
            self.EVars = EVars
            self.JVars= result[1]
            self.q2P = self.q1P
            self.q1P = self.JVars
        else:
            print("error while calculate")
            
</t>
<t tx="leo.20210411145610.76">def CalInvPositionEx(self, EVars, q1p=None, q2p=None, sol = -1):
    if sol == -1:
        sol = self.inv.FindTheBestSolution(EVars, q1p, q2p)
    if sol != None:
        result = self.inv.Cal_Inv_Position(EVars, sol)
        if result[0] != False:
            JVars= result[1]
            return True, JVars
        else:
            print("error while calculate")
            return False, 
    else:
        return False, 

</t>
<t tx="leo.20210411145610.77">def GetCurrentStatus(self):
    return self.EVars
</t>
<t tx="leo.20210411145610.78">@path ./
@others
@language python
@tabwidth -4
</t>
<t tx="leo.20210411145610.79">from OpenGL.GL import *
from OpenGL.GLU import *
import struct

#class for a 3d point
</t>
<t tx="leo.20210411145610.8">@path ./
@others
@language python
@tabwidth -4
</t>
<t tx="leo.20210411145610.80">class createpoint:
    @others
</t>
<t tx="leo.20210411145610.81">def __init__(self,p,c=(1,0,0)):
    self.point_size=0.5
    self.color=c
    self.x=p[0]
    self.y=p[1]
    self.z=p[2]
  
</t>
<t tx="leo.20210411145610.82">def glvertex(self):
    glVertex3f(self.x,self.y,self.z)

\\-4.#class for a 3d face on a model
</t>
<t tx="leo.20210411145610.83">class createtriangle:
    points=None
    normal=None

    @others
</t>
<t tx="leo.20210411145610.84">def __init__(self,p1,p2,p3,n=None):
    #3 points of the triangle
    self.points=createpoint(p1),createpoint(p2),createpoint(p3)
  
    #triangles normal
    self.normal=createpoint(self.calculate_normal(self.points[0],self.points[1],self.points[2]))#(0,1,0)#
  
#calculate vector / edge
</t>
<t tx="leo.20210411145610.85">def calculate_vector(self,p1,p2):
    return -p1.x+p2.x,-p1.y+p2.y,-p1.z+p2.z
  
</t>
<t tx="leo.20210411145610.86">def calculate_normal(self,p1,p2,p3):
    a=self.calculate_vector(p3,p2)
    b=self.calculate_vector(p3,p1)
    #calculate the cross product returns a vector
    return self.cross_product(a,b)    
  
</t>
<t tx="leo.20210411145610.87">def cross_product(self,p1,p2):
    return (p1[1]*p2[2]-p2[1]*p1[2]) , (p1[2]*p2[0])-(p2[2]*p1[0]) , (p1[0]*p2[1])-(p2[0]*p1[1])

</t>
<t tx="leo.20210411145610.88">class loader:
    @others
</t>
<t tx="leo.20210411145610.89">def __init__(self, filename):
    self.model=[]
    self.load_stl(filename)
#return the faces of the triangles
</t>
<t tx="leo.20210411145610.9">from math import *
import numpy as np

</t>
<t tx="leo.20210411145610.90">def get_triangles(self):
    if self.model:
        for face in self.model:
            yield face

#draw the models faces
</t>
<t tx="leo.20210411145610.91">def draw(self):
    glBegin(GL_TRIANGLES)
    for tri in self.get_triangles():
        glNormal3f(tri.normal.x,tri.normal.y,tri.normal.z)
        glVertex3f(tri.points[0].x,tri.points[0].y,tri.points[0].z)
        glVertex3f(tri.points[1].x,tri.points[1].y,tri.points[1].z)
        glVertex3f(tri.points[2].x,tri.points[2].y,tri.points[2].z)
    glEnd()
  
#load stl file detects if the file is a text file or binary file
</t>
<t tx="leo.20210411145610.92">def load_stl(self,filename):
    #read start of file to determine if its a binay stl file or a ascii stl file
    fp=open(filename,'rb')
    h=fp.read(80)
    type=h[0:5]
    fp.close()
    if type==b'solid':
        # print ("reading stl file "+str(filename))
        self.load_text_stl(filename)
    else:
        # print ("reading binary stl file "+str(filename))
        self.load_binary_stl(filename)
  
#read text stl match keywords to grab the points to build the model
</t>
<t tx="leo.20210411145610.93">def load_text_stl(self,filename):
    fp=open(filename,'r')

    for line in fp.readlines():
        words=line.split()
        if len(words)&gt;0:
            if words[0]=='solid':
                self.name=words[1]

            if words[0]=='facet':
                center=[0.0,0.0,0.0]
                triangle=[]
                normal=(eval(words[2]),eval(words[3]),eval(words[4]))
              
            if words[0]=='vertex':
                triangle.append((eval(words[1]),eval(words[2]),eval(words[3])))
              
              
            if words[0]=='endloop':
                #make sure we got the correct number of values before storing
                if len(triangle)==3:
                    self.model.append(createtriangle(triangle[0],triangle[1],triangle[2],normal))
    fp.close()

#load binary stl file check wikipedia for the binary layout of the file
#we use the struct library to read in and convert binary data into a format we can use
</t>
<t tx="leo.20210411145610.94">def load_binary_stl(self,filename):
    fp=open(filename,'rb')
    h=fp.read(80)

    l=struct.unpack('I',fp.read(4))[0]
    count=0
    while True:
        try:
            p=fp.read(12)
            if len(p)==12:
                n=struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]
              
            p=fp.read(12)
            if len(p)==12:
                p1=struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]

            p=fp.read(12)
            if len(p)==12:
                p2=struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]

            p=fp.read(12)
            if len(p)==12:
                p3=struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]

            new_tri=(n,p1,p2,p3)

            if len(new_tri)==4:
                tri=createtriangle(p1,p2,p3,n)
                self.model.append(tri)
            count+=1
            fp.read(2)

            if len(p)==0:
                break
        except EOFError:
            break
    fp.close()
</t>
<t tx="leo.20210411145610.95">@path ./
@others
@language python
@tabwidth -4

</t>
<t tx="leo.20210411145610.96">import numpy as np 
from math import *

</t>
<t tx="leo.20210411145610.97">class Trajectory(object):
    @others
</t>
<t tx="leo.20210411145610.98">def __init__(self, startPoint = None, endPoint = None):
    #startPoint and endPoint are numpy arrays
    self.startPoint = startPoint
    self.endPoint = endPoint
    self.sp_time = 0.1
    self.velocity = 5

</t>
<t tx="leo.20210411145610.99">def SetPoint(self, startPoint, endPoint, velocity = 5):
    self.startPoint = startPoint
    self.endPoint = endPoint
    self.velocity = velocity

</t>
<t tx="leo.20210411145736.1"></t>
<t tx="leo.20210411151110.1">https://pysimplegui.readthedocs.io/en/latest/

使用 https://pypi.org/project/PySimpleGUIQt/ 與使用 Pyside2 的比較

    https://www.slant.co/versus/18358/28865/~pyside_vs_pysimplegui
    
    基本 pysimplegui 教學:
    
    https://realpython.com/pysimplegui-python/

</t>
<t tx="leo.20210411151136.1">@language python
'''Use leo editor as IDE to development Package
ctrl + b to execute script
Recursively import all python files in a directory and clean the result.
'''

c.recursiveImport(
    dir_ = r'./',
    # use @clean to parse the associated files
    kind = '@clean',
    # if save_at_file = True, @@ will use to protect the source codes
    safe_at_file = False,
    theTypes = ['.py']
)
</t>
<t tx="leo.20210411153333.1"></t>
<t tx="leo.20210411153340.1"># hello_world.py
#pip install pysimplegui

@others
@language python
@tabwidth -4
</t>
<t tx="leo.20210411153407.1">import PySimpleGUI as sg

sg.Window(title="Hello World", layout=[[]], margins=(100, 50)).read()
</t>
<t tx="leo.20210411153417.1"># -*- coding: utf-8 -*-
@others
@language python
@tabwidth -4
</t>
<t tx="leo.20210411153437.1">import PySimpleGUI as sg
 
# Create some widgets
text = sg.Text("What's your name?")
text_entry = sg.InputText()
ok_btn = sg.Button('OK')
cancel_btn = sg.Button('Cancel')
layout = [[text, text_entry],
          [ok_btn, cancel_btn]]
 
# Create the Window
window = sg.Window('Hello PySimpleGUI', layout)
 
# Create the event loop
while True:
    event, values = window.read()
    if event in (None, 'Cancel'):
        # User closed the Window or hit the Cancel button
        break
    print(f'Event: {event}')
    print(str(values))
 
window.close()
</t>
<t tx="leo.20210411153520.1"># -*- coding: utf-8 -*-
# https://www.jianshu.com/u/69f40328d4f0
# https://github.com/china-testing/python-api-tesing
# https://china-testing.github.io/
# support q group: 630011153 144081101
@others
@language python
@tabwidth -4
</t>
<t tx="leo.20210411153540.1">import PySimpleGUI as sg
 
# Create some widgets
ok_btn = sg.Button('Open Second Window')
cancel_btn = sg.Button('Cancel')
layout = [[ok_btn, cancel_btn]]
 
# Create the first Window
window = sg.Window('Window 1', layout)
 
win2_active = False
 
# Create the event loop
while True:
    event1, values1 = window.read(timeout=100)
 
    if event1 in (None, 'Cancel'):
        # User closed the Window or hit the Cancel button
        break
 
    if not win2_active and event1 == 'Open Second Window':
        win2_active = True
        layout2 = [[sg.Text('Window 2')],
                   [sg.Button('Exit')]]
 
        window2 = sg.Window('Window 2', layout2)
 
    if win2_active:
        events2, values2 = window2.Read(timeout=100)
        if events2 is None or events2 == 'Exit':
            win2_active  = False
            window2.close()
 
window.close()
</t>
<t tx="leo.20210411153611.1">@others
@language python
@tabwidth -4
</t>
<t tx="leo.20210411153620.1">import PySimpleGUIQt as sg

layout = [[sg.Text('開始採用 PySimpleGUI!'),sg.Text(' '*5), sg.Text('On the same row'), ],
          [sg.Text('Input something here'), sg.Input('default text')],
          [sg.Text('Another line of text')]]

window = sg.Window('My first QT Window').Layout(layout)

event, values = window.Read()
</t>
<t tx="leo.20210411153622.1">@others
@language python
@tabwidth -4
</t>
<t tx="leo.20210411153632.1">import PySimpleGUIQt as sg

layout = [
        [sg.Text('Hello PySimpleGUI!'),sg.Text(' '*5), sg.Text('On the same row'), ],
        [sg.Text('Input something here'), sg.Input('default text')],
        [sg.Combo(['Combo 1', 'Combo 2', 'Combo 3'])],
        [sg.Listbox(['Listbox Item 1', 'Listbox Item 2', 'Listbox Item 3'], size=(30,10)),
        sg.Slider((1,100))],
        [sg.Slider((1,100), orientation='h')],
        [sg.Checkbox('Checkbox 1')],
        [sg.Checkbox('Checkbox 2')],
        [sg.Checkbox('Checkbox 3')],
        [sg.Radio('Radio1', group_id=1),sg.Radio('Radio2', group_id=1)],
        [sg.Spin([1,2,3,4])],
        [sg.Button('My Button')],
          ]
window = sg.Window('My first QT Window').Layout(layout)
event, values = window.Read()
</t>
<t tx="leo.20210411154008.1">PySimpleGUI 原始碼:

https://github.com/PySimpleGUI/PySimpleGUI

Documentation: https://www.PySimpleGUI.org

PySimpleGUI is a Python package that enables Python programmers of all levels to create GUIs. You specify your GUI window using a "layout" which contains widgets (they're called "Elements" in PySimpleGUI). Your layout is used to create a window using one of the 4 supported frameworks to display and interact with your window. Supported frameworks include tkinter, Qt, WxPython, or Remi. The term "wrapper" is sometimes used for these kinds of packages.

Your PySimpleGUI code is simpler and shorter than writing directly using the underlying framework because PySimpleGUI implements much of the "boilerplate code" for you. Additionally, interfaces are simplified to require as little code as possible to get the desired result. Depending on the program and framework used, a PySimpleGUI program may require 1/2 to 1/10th amount of code to create an identical window using one of the frameworks directly.

While the goal is to encapsulate/hide the specific objects and code used by the GUI framework you are running on top of, if needed you can access the frameworks' dependent widgets and windows directly. If a setting or feature is not yet exposed or accessible using the PySimpleGUI APIs, you are not walled off from the framework. You can expand capabilities without directly modifying the PySimpleGUI package itself.

Bridging the "GUI Gap"

Python has brought a large number of people into the programming community. The number of programs and the range of areas it touches is mindboggling. But more often than not, these and technologies are out of reach of all but a handful of people. The majority of Python programs are "command line" based. This isn't a problem for programmer-types as we're all used to interacting with computers through a text interface. While programmers don't have a problem with command-line interfaces, most "normal people" do. This creates a digital divide, a "GUI Gap".

Adding a GUI to a program opens that program up to a wider audience. It becomes more approachable. GUIs can also make interacting with some programs easier, even for those that are comfortable with a command-line interface. And finally, some problems require a GUI.</t>
<t tx="leo.20210411161804.1">https://pj4082.herokuapp.com 以 4082pj AT mde 綁定

透過 heroku login -i 取得 y:\home_ipv6\_netrc

並且利用 heroku git:remote -a pj4082 設定 git remote add

之後在近端 pj4082/.git/config 將會增加

[remote "heroku"]
	url = https://git.heroku.com/pj4082.git
	fetch = +refs/heads/*:refs/remotes/heroku/*
    
也就是以 heroku 代表 https://git.heroku.com/pj4082.git

因此改版至 Github 之後, 以 git push heroku 就可以將改版資料送到 Heroku 對應倉儲.</t>
<t tx="leo.20210411211731.1"></t>
</tnodes>
</leo_file>
